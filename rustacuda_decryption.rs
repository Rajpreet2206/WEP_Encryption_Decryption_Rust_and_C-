use std::time::Instant;
use rustacuda::prelude::*;
use rustacuda::launch;
use rustacuda::memory::DeviceBox;
fn count_characters(s: &str) -> usize {
    s.chars().count()
}
fn time_taken_by_the_function<F, R, Args>(function_name: &str, function: F, args: Args) -> R
where
    F: FnOnce(Args) -> R,
{
    let t_start = Instant::now();
    let result = function(args);
    let t_end = Instant::now();
    let time_duration = t_end - t_start;
    println!(
        "Executing the '{}' took {} microseconds",
        function_name,
        time_duration.as_micros()
    );
    result
}
fn wep_decrypt(ciphertext_and_key: (&str, &[u8])) -> String {
    let (ciphertext, wep_key) = ciphertext_and_key;
    let binary_ciphertext = ciphertext.replace(" ", "");
    let mut plaintext = String::new();
    let key_length = wep_key.len();
    for chunk in binary_ciphertext.as_bytes().chunks(8) {
        let byte_str = std::str::from_utf8(chunk).unwrap();
        let encrypted_byte = u8::from_str_radix(byte_str, 2).unwrap();
        let decrypted_byte = encrypted_byte ^ wep_key[plaintext.len() % key_length];
        plaintext.push(decrypted_byte as char);
    }
    plaintext
}
fn main() {
    // Initialize the CUDA API
    rustacuda::init(CudaFlags::empty()).expect("Failed to initialize CUDA");
    // Get the first available device
    let device = Device::get_device(0).expect("Failed to get CUDA device");
    let _context = Context::create_and_push(ContextFlags::MAP_HOST | ContextFlags::SCHED_AUTO, device)
        .expect("Failed to create CUDA context");
    // Allocate memory on the GPU
    let ciphertext = "11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110 11011101 11011110 11101100 10101101 10011100 11001111 11001000 10101001 10110011 10011010 10001010 11010011 10100011 10101010 11001110 11011110 11010100 11101100 10110001 10001011 11001011 11001001 10100010 11111101 10011100 11001111 11011100 10111110 10111000 10011101 11011001 11010010 10100011 10110011 11001110";
    let wep_key = vec![0xAA, 0xBB, 0xCC, 0xDD, 0xEE];
    let ciphertext_len = ciphertext.len() + 1; // Including null terminator
    let mut device_ciphertext = DeviceBox::new(ciphertext_len).expect("Failed to allocate memory on GPU");
    let mut device_decrypted_text = DeviceBox::new(ciphertext_len).expect("Failed to allocate memory on GPU");
    let mut device_wep_key = DeviceBox::new(wep_key.as_slice()).expect("Failed to allocate memory on GPU");
    // Copy data from host to device
    let ciphertext_bytes = ciphertext.as_bytes();
    device_ciphertext.copy_from(ciphertext_bytes).expect("Failed to copy ciphertext to GPU");
    // Launch the CUDA kernel
    let num_threads_per_block = 256;
    let num_blocks = (ciphertext_len + num_threads_per_block - 1) / num_threads_per_block;
    let stream = Stream::new(StreamFlags::NON_BLOCKING, None).expect("Failed to create CUDA stream");
    let params = (device_ciphertext.as_ptr(), ciphertext_len, device_wep_key.as_ptr(), wep_key.len(), device_decrypted_text.as_mut_ptr());
    unsafe {
        launch!(wep_decrypt_kernel<<<num_blocks, num_threads_per_block, 0, stream>>>(
            params
        )).expect("Failed to launch CUDA kernel");
    }
    // Copy the decrypted text back to the host
    let mut host_decrypted_text = vec![0u8; ciphertext_len];
    device_decrypted_text.copy_to(host_decrypted_text.as_mut_slice()).expect("Failed to copy decrypted text from GPU");
    // Clean up memory on the device
    device_ciphertext.free().expect("Failed to deallocate memory on GPU");
    device_decrypted_text.free().expect("Failed to deallocate memory on GPU");
    device_wep_key.free().expect("Failed to deallocate memory on GPU");
    // Clean up CUDA API
    rustacuda::deinit();
    let decrypted_text = String::from_utf8(host_decrypted_text).unwrap();
    let characters_count = count_characters(&ciphertext);
    let _duration = time_taken_by_the_function("wep_decrypt", wep_decrypt, (&ciphertext, &wep_key));
}
